# 任务规划与执行记录

## 1. 背景和动机

当前项目中存在两种拖拽模式：`native`（使用 HTML5 原生拖拽）和 `pointer`（自定义拖拽）。在 `dragMode` 为 `pointer` 时，拖拽预览元素被添加到拖拽目标的父元素，这可能导致以下问题：

1. 预览元素可能被父元素的 `overflow: hidden` 裁剪
2. 预览元素的 `z-index` 可能不够高，导致被其他元素遮挡
3. 预览元素的层级和定位受限于父元素的影响

而在 `dragMode` 为 `native` 时，虽然使用了浏览器的原生拖拽功能，但仍存在以下限制：

1. 原生拖拽的预览图像受浏览器限制，样式和交互能力有限
2. 不同浏览器对原生拖拽图像的呈现方式不一致
3. 开发者无法完全控制预览元素的外观和行为

为解决这些问题，借鉴 React-DnD 的 DragLayer 实现思路，引入"拖拽预览层"（Drag Preview Layer）概念，将拖拽预览与拖拽源组件分离，提供更灵活的自定义预览能力，同时支持两种拖拽模式。

## 2. 关键挑战和分析

- **当前预览元素处理机制：**
  - **native 模式**：
    - 使用 HTML5 原生拖拽 API (`dataTransfer.setDragImage`)
    - 预览图像在拖拽开始时设置一次，无法动态更改
    - 部分浏览器对预览图像有尺寸和性能限制

  - **pointer 模式**：
    - 预览元素通过克隆目标或自定义元素创建，使用 `position: fixed` 定位
    - 预览元素被添加到拖拽目标的父元素中，而非应用顶层
    - 样式和位置更新通过直接操作 DOM 实现

- **React-DnD DragLayer 核心思路：**
  - 预览层与拖拽源完全解耦，在应用顶层渲染
  - 通过订阅拖拽状态，获取必要信息（如 item、当前位置等）
  - 开发者可提供自定义组件进行渲染，获得更大灵活性

- **实现拖拽预览层的关键技术点：**
  - 创建全局/顶层的预览层组件或钩子
  - 建立拖拽源与预览层之间的通信机制
  - 确保预览元素始终位于顶层，避免裁剪问题
  - 针对不同拖拽模式实现对应的预览策略：
    - `pointer` 模式：完全控制预览元素的渲染和定位
    - `native` 模式：使用自定义组件渲染结合 `dataTransfer.setDragImage`
  - 设计统一 API，确保两种模式下体验一致

## 3. 高层任务拆分

1. **[ ] 任务一：探索项目结构，理解当前两种拖拽模式的实现**
   - **目标：** 全面理解 `useDrag`、`dragStore` 在 `native` 和 `pointer` 模式下的工作原理
   - **成功标准：**
     - 明确 `useDrag` 中两种模式的实现差异
     - 了解 `native` 模式下如何处理拖拽预览
     - 梳理 `dragStore` 的数据结构和状态管理方式
     - 识别需要扩展的关键点

2. **[ ] 任务二：设计统一的拖拽预览层架构**
   - **目标：** 设计可同时支持 `native` 和 `pointer` 模式的 `useDragPreview` 架构
   - **成功标准：**
     - 定义统一的 API 接口，支持两种模式
     - 设计在两种模式下共享状态的机制
     - 确定模式特定处理的分离策略

3. **[ ] 任务三：实现 `useDragPreview` 基础架构**
   - **目标：** 开发支持两种模式的基础结构
   - **成功标准：**
     - 构建预览层的基础组件或容器
     - 实现订阅拖拽状态的核心机制
     - 提供拖拽模式检测和适配能力

4. **[ ] 任务四：实现 `pointer` 模式下的预览功能**
   - **目标：** 完成 `pointer` 模式的预览渲染和定位
   - **成功标准：**
     - 实现预览元素添加到 `document.body` 的逻辑
     - 开发位置计算和更新机制
     - 处理拖拽开始、移动和结束的生命周期

5. **[ ] 任务五：实现 `native` 模式下的预览功能**
   - **目标：** 开发 `native` 模式下的增强预览能力
   - **成功标准：**
     - 实现通过 `dataTransfer.setDragImage` 设置初始预览
     - 开发跟踪原生拖拽事件的机制
     - 提供可选的"影子预览"以增强原生模式下的可视反馈

6. **[ ] 任务六：统一 API 和扩展组件渲染能力**
   - **目标：** 提供一致的 API 接口和组件渲染支持
   - **成功标准：**
     - 实现 `dragPreview.component` 选项，支持传入 Vue 组件
     - 确保组件能在两种模式下正确渲染
     - 设计公共属性传递机制（item、type、currentOffset 等）

7. **[ ] 任务七：优化模式间的无缝切换**
   - **目标：** 确保两种模式间可以平滑切换
   - **成功标准：**
     - 实现模式变更时的状态转换
     - 处理切换时的资源清理和重建
     - 提供调试辅助工具

8. **[ ] 任务八：开发示例和单元测试**
   - **目标：** 创建演示示例并编写测试确保功能正确
   - **成功标准：**
     - 开发针对两种模式的示例
     - 编写单元测试覆盖主要功能点
     - 验证在复杂场景中的表现（嵌套容器、高性能要求等）

9. **[ ] 任务九：文档完善和性能优化**
   - **目标：** 编写详细文档并优化性能
   - **成功标准：**
     - 完善两种模式下的 API 文档和使用示例
     - 确保不必要的渲染被避免
     - 监控和优化资源使用（内存、CPU）

## 4. 项目状态看板

- [ ] 任务一：探索项目结构，理解当前两种拖拽模式的实现
- [ ] 任务二：设计统一的拖拽预览层架构
- [ ] 任务三：实现 `useDragPreview` 基础架构
- [ ] 任务四：实现 `pointer` 模式下的预览功能
- [ ] 任务五：实现 `native` 模式下的预览功能
- [ ] 任务六：统一 API 和扩展组件渲染能力
- [ ] 任务七：优化模式间的无缝切换
- [ ] 任务八：开发示例和单元测试
- [ ] 任务九：文档完善和性能优化

## 5. 执行者反馈或请求帮助

### 实现总结

### 下一步计划

### 风险和挑战

1. **浏览器兼容性**：
   - 不同浏览器对原生拖拽 API 的实现存在差异，可能需要针对性处理
   - 特别是移动浏览器对拖拽支持有限，可能需要降级策略

2. **模式特定限制**：
   - `native` 模式下，浏览器对预览图像存在限制，无法实现某些动态效果
   - `pointer` 模式在某些复杂交互场景（如表单元素）可能有限制

3. **性能考量**：
   - 在高频拖拽操作下，需确保预览层不会导致性能问题
   - 特别是在同时支持两种模式时，避免重复计算和渲染

4. **API 设计平衡**：
   - 在保持 API 一致性和提供模式特定功能之间找到平衡
   - 确保用户不需要为切换模式而大量修改代码

## 6. 经验教训

1. **类型驱动开发**：在开发过程中，先定义好类型接口再实现具体功能，能够更清晰地梳理系统结构，减少后期可能的类型错误。

2. **合理使用现有基础设施**：通过扩展 `dragStore` 而非创建新的通信机制，简化了系统设计，并保持了与现有代码的一致性。

3. **模块化和关注点分离**：将预览元素渲染逻辑从 `useDrag` 分离到专门的 `useDragPreview` 钩子，使代码更易于理解和维护。

## 7. 实现注意事项

### 类型定义规范

1. **DragPreviewOptions 接口设计**：
   - 参考现有 `DragOptions` 和 `DropOptions` 的定义风格，保持一致性
   - 每个字段添加完整的 JSDoc 注释，包括描述、默认值和使用示例
   - 区分必填字段和可选字段，必填字段放在接口开头
   - 明确标注每个字段在不同拖拽模式下的行为差异

2. **类型复用与扩展**：
   - 复用现有的 `DragPreview` 接口，扩展其功能支持组件渲染
   - 对于组件类型，使用 Vue 的 `Component` 类型，支持 SFC 和渲染函数
   - 使用类型联合和交叉，灵活处理不同模式的特殊需求

3. **响应式类型处理**：
   - 对于可能变化的属性，使用 `MaybeRefOrGetter<T>` 类型包装
   - 参考现有代码中 `dragPreview`、`handle` 等字段的类型定义方式
   - 为复杂对象类型提供合理的泛型约束

### 示例类型定义

```typescript
/**
 * 拖拽预览层选项，控制预览层的行为和外观
 */
export interface DragPreviewOptions {
  /**
   * 预览层的目标容器，预览元素将被渲染到此容器中
   * 如果未提供，默认使用 document.body
   * @default document.body
   */
  container?: MaybeRefOrGetter<HTMLElement | null | undefined>

  /**
   * 预览层的 z-index 样式值，控制层叠顺序
   * @default 1000
   */
  zIndex?: MaybeRefOrGetter<number | undefined>

  /**
   * 自定义渲染预览内容的 Vue 组件
   * 该组件会接收拖拽状态作为 props
   */
  component?: MaybeRefOrGetter<Component | undefined>

  /**
   * 预览元素出现的动画效果配置
   */
  animation?: MaybeRefOrGetter<{
    duration?: number
    easing?: string
    initial?: Record<string, string>
    active?: Record<string, string>
  } | undefined>

  /**
   * 仅在 native 模式下使用的配置
   * 当设置为 true 时，将在原生拖拽之外显示自定义预览层
   * @default false
   */
  enhanceNativeDrag?: MaybeRefOrGetter<boolean | undefined>
}
```

### 响应式实现规范

1. **ref vs. shallowRef 选择**：
   - 使用 `shallowRef` 存储 DOM 元素引用和简单类型值
   - 对于需要深度响应的复杂对象，明确使用 `deepRef`
   - 非响应式工具函数和常量使用普通变量

2. **计算属性和监听器**：
   - 使用计算属性合并选项、处理默认值和转换类型
   - 提供 `immediate` 和 `flush` 选项配置的能力
   - 避免在监听器中执行昂贵操作，考虑使用 `throttle` 或 `requestAnimationFrame`

3. **生命周期和清理**：
   - 使用 `tryOnUnmounted` 注册所有清理函数
   - 对于 `setInterval` 和事件监听器，确保在组件卸载时清理
   - 提供手动清理方法，增强灵活性

4. **响应式传递**：
   - 监听 `dragStore` 中的拖拽状态变化
   - 使用 `toValue` 解包 `MaybeRefOrGetter` 类型的参数
   - 使用计算属性将拖拽状态暴露给模板和组件

## 8. 问题分析与修复

### 问题描述

### 问题原因分析

### 修复方案

### 修复效果

### 后续优化建议
