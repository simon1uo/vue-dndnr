# 任务规划与执行记录

## 1. 背景和动机

当前项目中 `dragMode` 为 `pointer` 时的实现中，拖拽预览元素被添加到拖拽目标的父元素，这可能导致以下问题：

1. 预览元素可能被父元素的 `overflow: hidden` 裁剪
2. 预览元素的 `z-index` 可能不够高，导致被其他元素遮挡
3. 预览元素的层级和定位受限于父元素的影响

为解决这些问题，借鉴 React-DnD 的 DragLayer 实现思路，引入"拖拽预览层"（Drag Preview Layer）概念，将拖拽预览与拖拽源组件分离，提供更灵活的自定义预览能力。

## 2. 关键挑战和分析

- **当前预览元素处理机制：**
  - 预览元素通过克隆目标或自定义元素创建，使用 `position: fixed` 定位
  - 预览元素被添加到拖拽目标的父元素中，而非应用顶层
  - 样式和位置更新通过直接操作 DOM 实现

- **React-DnD DragLayer 核心思路：**
  - 预览层与拖拽源完全解耦，在应用顶层渲染
  - 通过订阅拖拽状态，获取必要信息（如 item、当前位置等）
  - 开发者可提供自定义组件进行渲染，获得更大灵活性

- **实现拖拽预览层的关键技术点：**
  - 创建全局/顶层的预览层组件或钩子
  - 建立拖拽源与预览层之间的通信机制
  - 确保预览元素始终位于顶层，避免裁剪问题
  - 保留并增强现有的自定义预览能力
  - 设计合理的 API，确保与现有代码的兼容性

## 3. 高层任务拆分

1. **[ ] 任务一：探索项目结构，了解当前拖拽实现**
   - **目标：** 理解当前项目中 `useDrag`、`dragStore` 和 pointer 模式预览元素的实现细节
   - **成功标准：**
     - 明确 `useDrag` 中创建和管理预览元素的逻辑
     - 了解 `dragStore` 的数据结构和管理方式
     - 梳理与预览元素相关的函数和组件

2. **[ ] 任务二：设计拖拽预览层架构**
   - **目标：** 设计 `useDragPreview` 钩子和通信机制
   - **成功标准：**
     - 明确 `useDragPreview` 的 API 设计
     - 确定拖拽源与预览层的通信方式（通过 `dragStore` 或事件总线）
     - 设计预览层渲染策略（条件渲染、Portal 等）

3. **[ ] 任务三：实现 `useDragPreview` 核心功能**
   - **目标：** 开发 `useDragPreview` 钩子的基础功能
   - **成功标准：**
     - 实现订阅拖拽状态的机制
     - 开发预览元素渲染和定位逻辑
     - 确保预览元素添加到 `document.body` 或指定的 Portal 目标

4. **[ ] 任务四：修改 `useDrag` 关联逻辑**
   - **目标：** 调整 `useDrag` 中的预览元素处理逻辑，与新的预览层协作
   - **成功标准：**
     - 更新 `useDrag` 在 pointer 模式下的预览处理
     - 在拖拽开始时通知预览层而非自行创建预览元素
     - 拖拽过程中提供必要的状态更新

5. **[ ] 任务五：扩展 API 支持组件渲染**
   - **目标：** 增强 `dragPreview` 选项，支持传入 Vue 组件或渲染函数
   - **成功标准：**
     - 实现 `dragPreview.component` 选项
     - 确保组件能接收到必要的 props（如 item、type、currentOffset 等）
     - 保证与现有 `dragPreview.element` 的兼容性

6. **[ ] 任务六：开发示例和单元测试**
   - **目标：** 创建演示示例并编写测试确保功能正确
   - **成功标准：**
     - 开发至少两个示例：基础克隆预览和自定义组件预览
     - 编写单元测试覆盖主要功能点
     - 验证在不同场景下的表现（如嵌套滚动容器）

7. **[ ] 任务七：文档完善和性能优化**
   - **目标：** 编写详细文档并优化性能
   - **成功标准：**
     - 完善 API 文档和使用示例
     - 确保不必要的渲染被避免（如使用 `shallowRef`）
     - 检查并解决可能的内存泄漏问题

## 4. 项目状态看板

- [ ] 任务一：探索项目结构，了解当前拖拽实现
- [ ] 任务二：设计拖拽预览层架构
- [ ] 任务三：实现 `useDragPreview` 核心功能
- [ ] 任务四：修改 `useDrag` 关联逻辑
- [ ] 任务五：扩展 API 支持组件渲染
- [ ] 任务六：开发示例和单元测试
- [ ] 任务七：文档完善和性能优化

## 5. 执行者反馈或请求帮助

### 实现总结

### 下一步计划

### 风险和挑战

1. **与现有代码的兼容性**：
   - 已修改的 `useDrag` 逻辑可能与现有使用代码不完全兼容，需要谨慎测试
   - 特别是在切换 `dragMode` 时的行为变化

2. **组件渲染**：
   - 目前组件渲染部分使用较为简化的方式实现，在复杂组件情况下可能需要更复杂的 mount 机制
   - 可能需要使用 `createApp` 和 `mount` 来确保正确渲染

3. **动态 z-index**：
   - 预览层与页面其他元素的层级关系需要更精细的控制
   - 可能需要添加全局配置选项来设置默认的 z-index 范围

## 6. 经验教训

1. **类型驱动开发**：在开发过程中，先定义好类型接口再实现具体功能，能够更清晰地梳理系统结构，减少后期可能的类型错误。

2. **合理使用现有基础设施**：通过扩展 `dragStore` 而非创建新的通信机制，简化了系统设计，并保持了与现有代码的一致性。

3. **模块化和关注点分离**：将预览元素渲染逻辑从 `useDrag` 分离到专门的 `useDragPreview` 钩子，使代码更易于理解和维护。

## 7. 问题分析与修复

### 问题描述

经测试发现，在 `dragMode` 为 `pointer` 模式下，传入的元素和组件作为 `previewElement` 都没有生效，仍然使用原来的元素作为预览元素。

### 问题原因分析

1. **组件渲染问题**：
   - `useDragPreview.ts` 中的组件渲染逻辑存在缺陷，只创建了占位符而没有真正渲染组件
   - 缺少 `createApp` 和 `mount` 的实现，导致组件无法正确渲染

2. **预览选项传递问题**：
   - `useDrag.ts` 中将预览选项传递给 `dragStore`，但在 `useDragPreview.ts` 中没有正确处理这些选项
   - 没有建立动态预览选项与初始选项的合并机制

### 修复方案

1. **完善组件渲染逻辑**：
   - 使用 `createApp` 和 `mount` 正确渲染 Vue 组件
   - 处理组件卸载和清理

2. **实现动态预览选项处理**：
   - 添加 `dynamicPreviewOptions` 响应式引用来存储从 `dragStore` 获取的预览选项
   - 在 `mergedOptions` 计算属性中合并初始选项和动态选项
   - 监听 `dynamicPreviewOptions` 变化，触发重新渲染

3. **优化预览元素清理**：
   - 确保在拖拽结束时正确清理预览元素和应用实例
   - 添加 `previewApp` 引用来管理组件应用实例

### 修复效果

### 后续优化建议

1. **性能优化**：
   - 考虑使用 `requestAnimationFrame` 代替 `setInterval` 进行位置更新
   - 使用 `throttle` 或 `debounce` 减少不必要的渲染

2. **API 增强**：
   - 添加更多自定义选项，如动画效果、延迟渲染等
   - 提供更灵活的定位策略，如相对于特定元素定位

3. **兼容性处理**：
   - 增加对不同浏览器和设备的兼容性测试
   - 处理触摸事件和鼠标事件的差异
